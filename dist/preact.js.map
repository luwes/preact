{"version":3,"file":"preact.js","sources":["../src/constants.js","../src/diff/props.js","../src/options.js","../src/create-element.js","../src/util.js","../src/diff/index.js","../src/diff/children.js","../src/render.js","../src/clone-element.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n */\nexport function diffProps(dom, newProps, oldProps, isSvg) {\n\tfor (let i in newProps) {\n\t\tif (i!=='children' && i!=='key' && (!oldProps || oldProps[i]!=newProps[i])) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n\tfor (let i in oldProps) {\n\t\tif (i!=='children' && i!=='key' && (!newProps || !(i in newProps))) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nlet CAMEL_REG = /-?(?=[A-Z])/g;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nfunction setProperty(dom, name, value, oldValue, isSvg) {\n\tlet v;\n\tif (name==='class' || name==='className') name = isSvg ? 'class' : 'className';\n\n\tif (name==='style') {\n\n\t\t/* Possible golfing activities for setting styles:\n\t\t *   - we could just drop String style values. They're not supported in other VDOM libs.\n\t\t *   - assigning to .style sets .style.cssText - TODO: benchmark this, might not be worth the bytes.\n\t\t *   - assigning also casts to String, and ignores invalid values. This means assigning an Object clears all styles.\n\t\t */\n\t\tlet s = dom.style;\n\n\t\tif (typeof value==='string') {\n\t\t\ts.cssText = value;\n\t\t}\n\t\telse {\n\t\t\tif (typeof oldValue==='string') s.cssText = '';\n\t\t\telse {\n\t\t\t\t// remove values not in the new list\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) s.setProperty(i.replace(CAMEL_REG, '-'), '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, '-'), typeof v==='number' && IS_NON_DIMENSIONAL.test(i)===false ? (v + 'px') : v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (name==='dangerouslySetInnerHTML') {\n\t\treturn;\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0]==='o' && name[1]==='n') {\n\t\tlet useCapture = name !== (name=name.replace(/Capture$/, ''));\n\t\tlet nameLower = name.toLowerCase();\n\t\tname = (nameLower in dom ? nameLower : name).substring(2);\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\telse {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(dom._listeners || (dom._listeners = {}))[name] = value;\n\t}\n\t// Wesley 2019-03-24\n\t// Removed (name in dom) condition so most props are added on the dom element.\n\telse if (name!=='list' && name!=='tagName' && !isSvg) {\n\t\tdom[name] = value==null ? '' : value;\n\t}\n\t// Wesley 2019-03-24\n\t// Removed removeAttribute and setAttribute, handle this in Swiss element.\n\t// else if (value==null || value===false) {\n\t// \tdom.removeAttribute(name);\n\t// }\n\t// else if (typeof value!=='function') {\n\t// \tdom.setAttribute(name, value);\n\t// }\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event ? options.event(e) : e);\n}\n","/** @type {import('./index').Options}  */\nconst options = {};\n\nexport default options;\n","import options from './options';\n\n/**\n  * Create an virtual node (used for JSX)\n  * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n  * constructor for this virtual node\n  * @param {object | null | undefined} [props] The properties of the virtual node\n  * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n  * @returns {import('./internal').VNode}\n  */\nexport function createElement(type, props, children) {\n\tif (props==null) props = {};\n\tif (arguments.length>3) {\n\t\tchildren = [children];\n\t\tfor (let i=3; i<arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children!=null) {\n\t\tprops.children = children;\n\t}\n\n\t// \"type\" may be undefined during development. The check is needed so that\n\t// we can display a nice error message with our debug helpers\n\tif (type!=null && type.defaultProps!=null) {\n\t\tfor (let i in type.defaultProps) {\n\t\t\tif (props[i]===undefined) props[i] = type.defaultProps[i];\n\t\t}\n\t}\n\tlet ref = props.ref;\n\tif (ref) delete props.ref;\n\tlet key = props.key;\n\tif (key) delete props.key;\n\n\treturn createVNode(type, props, null, key, ref);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object} props The properites of this virtual node\n * @param {string | number} text If this virtual node represents a text node,\n * this is the text of the node\n * @param {string |number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, text, key, ref) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\ttext,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_dom: null,\n\t\t_lastDomChild: null\n\t};\n\n\tif (options.vnode) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn {};\n}\n\nexport /* istanbul ignore next */ function Fragment() { }\n\n/**\n * Coerce an untrusted value into a VNode\n * Specifically, this should be used anywhere a user could provide a boolean, string, or number where\n * a VNode or Component is desired instead\n * @param {boolean | string | number | import('./internal').VNode} possibleVNode A possible VNode\n * @returns {import('./internal').VNode}\n */\nexport function coerceToVNode(possibleVNode) {\n\tif (possibleVNode == null || typeof possibleVNode === 'boolean') return null;\n\tif (typeof possibleVNode === 'string' || typeof possibleVNode === 'number') {\n\t\treturn createVNode(null, null, possibleVNode, null, null);\n\t}\n\n\tif (Array.isArray(possibleVNode)) {\n\t\treturn createElement(Fragment, null, possibleVNode);\n\t}\n\n\t// Clone vnode if it has already been used. ceviche/#57\n\tif (possibleVNode._dom!=null) {\n\t\treturn createVNode(possibleVNode.type, possibleVNode.props, possibleVNode.text, possibleVNode.key, null);\n\t}\n\n\treturn possibleVNode;\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps } from './props';\nimport { removeNode } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement | Text} dom The DOM element representing\n * the virtual nodes under diff\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | null} newVNode The new virtual node\n * @param {import('../internal').VNode | null} oldVNode The old virtual node\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n */\nexport function diff(dom, parentDom, newVNode, oldVNode, isSvg, excessDomChildren, force) {\n\n\t// If the previous type doesn't match the new type we drop the whole subtree\n\tif (oldVNode==null || newVNode==null || oldVNode.type!==newVNode.type) {\n\t\tif (oldVNode!=null) unmount(oldVNode);\n\t\tif (newVNode==null) return null;\n\t\tdom = null;\n\t\toldVNode = EMPTY_OBJ;\n\t}\n\n\tif (options.diff) options.diff(newVNode);\n\n\tlet newType = newVNode.type;\n\n\ttry {\n\t\tif (oldVNode.type===Fragment || newType===Fragment) {\n\t\t\tdiffChildren(parentDom, newVNode, oldVNode, isSvg, excessDomChildren);\n\n\t\t\tif (newVNode._children.length) {\n\t\t\t\tdom = newVNode._children[0]._dom;\n\t\t\t\tnewVNode._lastDomChild = newVNode._children[newVNode._children.length - 1]._dom;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdom = diffElementNodes(dom, newVNode, oldVNode, isSvg, excessDomChildren);\n\n\t\t\tif (newVNode.ref && (oldVNode.ref !== newVNode.ref)) {\n\t\t\t\tapplyRef(newVNode.ref, dom);\n\t\t\t}\n\t\t}\n\n\t\tnewVNode._dom = dom;\n\n\t\tif (options.diffed) options.diffed(newVNode);\n\t}\n\tcatch (e) {\n\n\t}\n\n\treturn dom;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(dom, newVNode, oldVNode, isSvg, excessDomChildren) {\n\tlet d = dom;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type==='svg' || isSvg;\n\n\tif (dom==null && excessDomChildren!=null) {\n\t\tfor (let i=0; i<excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\t\t\tif (child!=null && (newVNode.type===null ? child.nodeType===3 : child.localName===newVNode.type)) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom==null) {\n\t\tdom = newVNode.type===null ? document.createTextNode(newVNode.text) : isSvg ? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type) : document.createElement(newVNode.type);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t}\n\tnewVNode._dom = dom;\n\n\tif (newVNode.type===null) {\n\t\tif ((d===null || dom===d) && newVNode.text!==oldVNode.text) {\n\t\t\tdom.data = newVNode.text;\n\t\t}\n\t}\n\telse {\n\t\tif (excessDomChildren!=null && dom.childNodes!=null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\t\tif (newVNode!==oldVNode) {\n\t\t\tlet oldProps = oldVNode.props;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// if we're hydrating, use the element's attributes as its current props:\n\t\t\tif (oldProps==null) {\n\t\t\t\toldProps = {};\n\t\t\t\tif (excessDomChildren!=null) {\n\t\t\t\t\tlet name;\n\t\t\t\t\tfor (let i=0; i<dom.attributes.length; i++) {\n\t\t\t\t\t\tname = dom.attributes[i].name;\n\t\t\t\t\t\toldProps[name=='class' && newProps.className ? 'className' : name] = dom.attributes[i].value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html!=oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = newHtml && newHtml.__html || '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newProps.multiple) {\n\t\t\t\tdom.multiple = newProps.multiple;\n\t\t\t}\n\n\t\t\tdiffChildren(dom, newVNode, oldVNode, newVNode.type==='foreignObject' ? false : isSvg, excessDomChildren);\n\t\t\tdiffProps(dom, newProps, oldProps, isSvg);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} [ref=null]\n * @param {any} [value]\n */\nexport function applyRef(ref, value) {\n\ttry {\n\t\tif (typeof ref=='function') ref(value);\n\t\telse ref.current = value;\n\t}\n\tcatch (e) {\n\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {boolean} skipRemove Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif (r = vnode.ref) {\n\t\tapplyRef(r, null);\n\t}\n\n\tif (!skipRemove && vnode._lastDomChild==null && (skipRemove = ((r = vnode._dom)!=null))) removeNode(r);\n\n\tvnode._dom = vnode._lastDomChild = null;\n\n\tif (r = vnode._children) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tunmount(r[i], skipRemove);\n\t\t}\n\t}\n}\n","import { diff, unmount } from './index';\nimport { coerceToVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n */\nexport function diffChildren(parentDom, newParentVNode, oldParentVNode, isSvg, excessDomChildren) {\n\tlet childVNode, i, j, p, index, oldVNode, newDom,\n\t\tnextDom, sibDom, focus,\n\t\tchildDom;\n\n\tlet newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, newParentVNode._children=[], coerceToVNode);\n\tlet oldChildren = oldParentVNode!=null && oldParentVNode!=EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tchildDom = oldChildrenLength ? oldChildren[0] && oldChildren[0]._dom : null;\n\tif (excessDomChildren!=null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tif (excessDomChildren[i]!=null) {\n\t\t\t\tchildDom = excessDomChildren[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<newChildren.length; i++) {\n\t\tchildVNode = newChildren[i] = coerceToVNode(newChildren[i]);\n\t\toldVNode = index = null;\n\n\t\t// Check if we find a corresponding element in oldChildren and store the\n\t\t// index where the element was found.\n\t\tp = oldChildren[i];\n\t\tif (p != null && (childVNode.key==null && p.key==null ? (childVNode.type === p.type) : (childVNode.key === p.key))) {\n\t\t\tindex = i;\n\t\t}\n\t\telse {\n\t\t\tfor (j=0; j<oldChildrenLength; j++) {\n\t\t\t\tp = oldChildren[j];\n\t\t\t\tif (p!=null) {\n\t\t\t\t\tif (childVNode.key==null && p.key==null ? (childVNode.type === p.type) : (childVNode.key === p.key)) {\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we have found a corresponding old element we store it in a variable\n\t\t// and delete it from the array. That way the next iteration can skip this\n\t\t// element.\n\t\tif (index!=null) {\n\t\t\toldVNode = oldChildren[index];\n\t\t\toldChildren[index] = null;\n\t\t}\n\n\t\tnextDom = childDom!=null && childDom.nextSibling;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(oldVNode==null ? null : oldVNode._dom, parentDom, childVNode, oldVNode, isSvg, excessDomChildren, null);\n\n\t\t// Only proceed if the vnode has not been unmounted by `diff()` above.\n\t\tif (childVNode!=null && newDom !=null) {\n\t\t\t// Store focus in case moving children around changes it. Note that we\n\t\t\t// can't just check once for every tree, because we have no way to\n\t\t\t// differentiate wether the focus was reset by the user in a lifecycle\n\t\t\t// hook or by reordering dom nodes.\n\t\t\tfocus = document.activeElement;\n\n\t\t\tif (childVNode._lastDomChild != null) {\n\t\t\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t\t\t// have a non-null _lastDomChild. Continue the diff from the end of\n\t\t\t\t// this Fragment's DOM tree.\n\t\t\t\tnewDom = childVNode._lastDomChild;\n\t\t\t}\n\t\t\telse if (excessDomChildren==oldVNode || newDom!=childDom || newDom.parentNode==null) {\n\t\t\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t\t\t// The values only have the same type when `null`.\n\n\t\t\t\touter: if (childDom==null || childDom.parentNode!==parentDom) {\n\t\t\t\t\tparentDom.appendChild(newDom);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsibDom = childDom;\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ((sibDom=sibDom.nextSibling) && j++<oldChildrenLength/2) {\n\t\t\t\t\t\tif (sibDom===newDom) {\n\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparentDom.insertBefore(newDom, childDom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Restore focus if it was changed\n\t\t\tif (focus!==document.activeElement) {\n\t\t\t\tfocus.focus();\n\t\t\t}\n\n\t\t\tchildDom = newDom!=null ? newDom.nextSibling : nextDom;\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode. Only used by `hydrate`\n\tif (excessDomChildren!=null && newParentVNode.type!==Fragment) for (i=excessDomChildren.length; i--; ) if (excessDomChildren[i]!=null) removeNode(excessDomChildren[i]);\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i=oldChildrenLength; i--; ) if (oldChildren[i]!=null) unmount(oldChildren[i]);\n}\n\n/**\n * Flatten a virtual nodes children to a single dimensional array\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @param {Array<import('../internal').VNode | null>} [flattened] An flat array of children to modify\n */\nexport function toChildArray(children, flattened, map) {\n\tif (flattened == null) flattened = [];\n\tif (children==null || typeof children === 'boolean') {}\n\telse if (Array.isArray(children)) {\n\t\tfor (let i=0; i < children.length; i++) {\n\t\t\ttoChildArray(children[i], flattened);\n\t\t}\n\t}\n\telse {\n\t\tflattened.push(map ? map(children) : children);\n\t}\n\n\treturn flattened;\n}\n","import { EMPTY_ARR } from './constants';\nimport { diffChildren } from './diff/children';\nimport { createElement, Fragment } from './create-element';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet oldVNode = parentDom._prevVNode;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\tdiffChildren(parentDom, parentDom._prevVNode = vnode, oldVNode, parentDom.ownerSVGElement!==undefined, oldVNode ? null : EMPTY_ARR.slice.call(parentDom.childNodes), vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tparentDom._prevVNode = null;\n\trender(vnode, parentDom);\n}\n","import { assign } from './util';\nimport { EMPTY_ARR } from './constants';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n */\nexport function cloneElement(vnode, props) {\n\tprops = assign(assign({}, vnode.props), props);\n\tif (arguments.length>2) props.children = EMPTY_ARR.slice.call(arguments, 2);\n\treturn createVNode(vnode.type, props, null, props.key || vnode.key, props.ref || vnode.ref);\n}\n"],"names":["const","CAMEL_REG","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","options","createElement","type","props","children","i","ref","key","arguments","length","push","defaultProps","undefined","createVNode","text","vnode","_children","_dom","_lastDomChild","Fragment","coerceToVNode","possibleVNode","Array","isArray","diffProps","dom","newProps","oldProps","isSvg","setProperty","name","value","oldValue","v","s","useCapture","nameLower","style","cssText","replace","test","toLowerCase","substring","addEventListener","eventProxy","removeEventListener","_listeners","e","this","event","assign","obj","let","removeNode","node","parentNode","removeChild","diff","parentDom","newVNode","oldVNode","excessDomChildren","force","unmount","newType","diffChildren","diffElementNodes","applyRef","diffed","child","oldHtml","newHtml","d","nodeType","localName","document","createTextNode","createElementNS","data","childNodes","slice","call","attributes","className","dangerouslySetInnerHTML","__html","innerHTML","multiple","current","skipRemove","r","newParentVNode","oldParentVNode","childVNode","j","p","index","newDom","nextDom","sibDom","focus","newChildren","toChildArray","oldChildren","oldChildrenLength","childDom","nextSibling","activeElement","outer","appendChild","insertBefore","flattened","map","render","_prevVNode","ownerSVGElement"],"mappings":"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"}