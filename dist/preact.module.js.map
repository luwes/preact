{"version":3,"file":"preact.module.js","sources":["../src/constants.js","../src/diff/props.js","../src/options.js","../src/create-element.js","../src/util.js","../src/diff/index.js","../src/diff/children.js","../src/render.js","../src/clone-element.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n */\nexport function diffProps(dom, newProps, oldProps, isSvg) {\n\tfor (let i in newProps) {\n\t\tif (i!=='children' && i!=='key' && (!oldProps || oldProps[i]!=newProps[i])) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n\tfor (let i in oldProps) {\n\t\tif (i!=='children' && i!=='key' && (!newProps || !(i in newProps))) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nlet CAMEL_REG = /-?(?=[A-Z])/g;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nfunction setProperty(dom, name, value, oldValue, isSvg) {\n\tlet v;\n\tif (name==='class' || name==='className') name = isSvg ? 'class' : 'className';\n\n\tif (name==='style') {\n\n\t\t/* Possible golfing activities for setting styles:\n\t\t *   - we could just drop String style values. They're not supported in other VDOM libs.\n\t\t *   - assigning to .style sets .style.cssText - TODO: benchmark this, might not be worth the bytes.\n\t\t *   - assigning also casts to String, and ignores invalid values. This means assigning an Object clears all styles.\n\t\t */\n\t\tlet s = dom.style;\n\n\t\tif (typeof value==='string') {\n\t\t\ts.cssText = value;\n\t\t}\n\t\telse {\n\t\t\tif (typeof oldValue==='string') s.cssText = '';\n\t\t\telse {\n\t\t\t\t// remove values not in the new list\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) s.setProperty(i.replace(CAMEL_REG, '-'), '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, '-'), typeof v==='number' && IS_NON_DIMENSIONAL.test(i)===false ? (v + 'px') : v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (name==='dangerouslySetInnerHTML') {\n\t\treturn;\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0]==='o' && name[1]==='n') {\n\t\tlet useCapture = name !== (name=name.replace(/Capture$/, ''));\n\t\tlet nameLower = name.toLowerCase();\n\t\tname = (nameLower in dom ? nameLower : name).substring(2);\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\telse {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(dom._listeners || (dom._listeners = {}))[name] = value;\n\t}\n\telse if (name!=='list' && name!=='tagName' && !isSvg && (name in dom)) {\n\t\tdom[name] = value==null ? '' : value;\n\t}\n\telse if (value==null || value===false) {\n\t\tdom.removeAttribute(name);\n\t}\n\telse if (typeof value!=='function') {\n\t\tdom.setAttribute(name, value);\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event ? options.event(e) : e);\n}\n","/** @type {import('./index').Options}  */\nconst options = {};\n\nexport default options;\n","import options from './options';\n\n/**\n  * Create an virtual node (used for JSX)\n  * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n  * constructor for this virtual node\n  * @param {object | null | undefined} [props] The properties of the virtual node\n  * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n  * @returns {import('./internal').VNode}\n  */\nexport function createElement(type, props, children) {\n\tif (props==null) props = {};\n\tif (arguments.length>3) {\n\t\tchildren = [children];\n\t\tfor (let i=3; i<arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children!=null) {\n\t\tprops.children = children;\n\t}\n\n\t// \"type\" may be undefined during development. The check is needed so that\n\t// we can display a nice error message with our debug helpers\n\tif (type!=null && type.defaultProps!=null) {\n\t\tfor (let i in type.defaultProps) {\n\t\t\tif (props[i]===undefined) props[i] = type.defaultProps[i];\n\t\t}\n\t}\n\tlet ref = props.ref;\n\tif (ref) delete props.ref;\n\tlet key = props.key;\n\tif (key) delete props.key;\n\n\treturn createVNode(type, props, null, key, ref);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object} props The properites of this virtual node\n * @param {string | number} text If this virtual node represents a text node,\n * this is the text of the node\n * @param {string |number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, text, key, ref) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\ttext,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_dom: null,\n\t\t_lastDomChild: null\n\t};\n\n\tif (options.vnode) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn {};\n}\n\nexport /* istanbul ignore next */ function Fragment() { }\n\n/**\n * Coerce an untrusted value into a VNode\n * Specifically, this should be used anywhere a user could provide a boolean, string, or number where\n * a VNode or Component is desired instead\n * @param {boolean | string | number | import('./internal').VNode} possibleVNode A possible VNode\n * @returns {import('./internal').VNode}\n */\nexport function coerceToVNode(possibleVNode) {\n\tif (possibleVNode == null || typeof possibleVNode === 'boolean') return null;\n\tif (typeof possibleVNode === 'string' || typeof possibleVNode === 'number') {\n\t\treturn createVNode(null, null, possibleVNode, null, null);\n\t}\n\n\tif (Array.isArray(possibleVNode)) {\n\t\treturn createElement(Fragment, null, possibleVNode);\n\t}\n\n\t// Clone vnode if it has already been used. ceviche/#57\n\tif (possibleVNode._dom!=null) {\n\t\treturn createVNode(possibleVNode.type, possibleVNode.props, possibleVNode.text, possibleVNode.key, null);\n\t}\n\n\treturn possibleVNode;\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps } from './props';\nimport { removeNode } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement | Text} dom The DOM element representing\n * the virtual nodes under diff\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | null} newVNode The new virtual node\n * @param {import('../internal').VNode | null} oldVNode The old virtual node\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n */\nexport function diff(dom, parentDom, newVNode, oldVNode, isSvg, excessDomChildren, force) {\n\n\t// If the previous type doesn't match the new type we drop the whole subtree\n\tif (oldVNode==null || newVNode==null || oldVNode.type!==newVNode.type) {\n\t\tif (oldVNode!=null) unmount(oldVNode);\n\t\tif (newVNode==null) return null;\n\t\tdom = null;\n\t\toldVNode = EMPTY_OBJ;\n\t}\n\n\tif (options.diff) options.diff(newVNode);\n\n\tlet newType = newVNode.type;\n\n\ttry {\n\t\tif (oldVNode.type===Fragment || newType===Fragment) {\n\t\t\tdiffChildren(parentDom, newVNode, oldVNode, isSvg, excessDomChildren);\n\n\t\t\tif (newVNode._children.length) {\n\t\t\t\tdom = newVNode._children[0]._dom;\n\t\t\t\tnewVNode._lastDomChild = newVNode._children[newVNode._children.length - 1]._dom;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdom = diffElementNodes(dom, newVNode, oldVNode, isSvg, excessDomChildren);\n\n\t\t\tif (newVNode.ref && (oldVNode.ref !== newVNode.ref)) {\n\t\t\t\tapplyRef(newVNode.ref, dom);\n\t\t\t}\n\t\t}\n\n\t\tnewVNode._dom = dom;\n\n\t\tif (options.diffed) options.diffed(newVNode);\n\t}\n\tcatch (e) {\n\n\t}\n\n\treturn dom;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(dom, newVNode, oldVNode, isSvg, excessDomChildren) {\n\tlet d = dom;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type==='svg' || isSvg;\n\n\tif (dom==null && excessDomChildren!=null) {\n\t\tfor (let i=0; i<excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\t\t\tif (child!=null && (newVNode.type===null ? child.nodeType===3 : child.localName===newVNode.type)) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom==null) {\n\t\tdom = newVNode.type===null ? document.createTextNode(newVNode.text) : isSvg ? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type) : document.createElement(newVNode.type);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t}\n\tnewVNode._dom = dom;\n\n\tif (newVNode.type===null) {\n\t\tif ((d===null || dom===d) && newVNode.text!==oldVNode.text) {\n\t\t\tdom.data = newVNode.text;\n\t\t}\n\t}\n\telse {\n\t\tif (excessDomChildren!=null && dom.childNodes!=null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\t\tif (newVNode!==oldVNode) {\n\t\t\tlet oldProps = oldVNode.props;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// if we're hydrating, use the element's attributes as its current props:\n\t\t\tif (oldProps==null) {\n\t\t\t\toldProps = {};\n\t\t\t\tif (excessDomChildren!=null) {\n\t\t\t\t\tlet name;\n\t\t\t\t\tfor (let i=0; i<dom.attributes.length; i++) {\n\t\t\t\t\t\tname = dom.attributes[i].name;\n\t\t\t\t\t\toldProps[name=='class' && newProps.className ? 'className' : name] = dom.attributes[i].value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html!=oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = newHtml && newHtml.__html || '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newProps.multiple) {\n\t\t\t\tdom.multiple = newProps.multiple;\n\t\t\t}\n\n\t\t\tdiffChildren(dom, newVNode, oldVNode, newVNode.type==='foreignObject' ? false : isSvg, excessDomChildren);\n\t\t\tdiffProps(dom, newProps, oldProps, isSvg);\n\n\t\t\tdom.props = newProps;\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} [ref=null]\n * @param {any} [value]\n */\nexport function applyRef(ref, value) {\n\ttry {\n\t\tif (typeof ref=='function') ref(value);\n\t\telse ref.current = value;\n\t}\n\tcatch (e) {\n\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {boolean} skipRemove Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif (r = vnode.ref) {\n\t\tapplyRef(r, null);\n\t}\n\n\tif (!skipRemove && vnode._lastDomChild==null && (skipRemove = ((r = vnode._dom)!=null))) removeNode(r);\n\n\tvnode._dom = vnode._lastDomChild = null;\n\n\tif (r = vnode._children) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tunmount(r[i], skipRemove);\n\t\t}\n\t}\n}\n","import { diff, unmount } from './index';\nimport { coerceToVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n */\nexport function diffChildren(parentDom, newParentVNode, oldParentVNode, isSvg, excessDomChildren) {\n\tlet childVNode, i, j, p, index, oldVNode, newDom,\n\t\tnextDom, sibDom, focus,\n\t\tchildDom;\n\n\tlet newChildren = newParentVNode._children || toChildArray(newParentVNode.props.children, newParentVNode._children=[], coerceToVNode);\n\tlet oldChildren = oldParentVNode!=null && oldParentVNode!=EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tchildDom = oldChildrenLength ? oldChildren[0] && oldChildren[0]._dom : null;\n\tif (excessDomChildren!=null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tif (excessDomChildren[i]!=null) {\n\t\t\t\tchildDom = excessDomChildren[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<newChildren.length; i++) {\n\t\tchildVNode = newChildren[i] = coerceToVNode(newChildren[i]);\n\t\toldVNode = index = null;\n\n\t\t// Check if we find a corresponding element in oldChildren and store the\n\t\t// index where the element was found.\n\t\tp = oldChildren[i];\n\t\tif (p != null && (childVNode.key==null && p.key==null ? (childVNode.type === p.type) : (childVNode.key === p.key))) {\n\t\t\tindex = i;\n\t\t}\n\t\telse {\n\t\t\tfor (j=0; j<oldChildrenLength; j++) {\n\t\t\t\tp = oldChildren[j];\n\t\t\t\tif (p!=null) {\n\t\t\t\t\tif (childVNode.key==null && p.key==null ? (childVNode.type === p.type) : (childVNode.key === p.key)) {\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we have found a corresponding old element we store it in a variable\n\t\t// and delete it from the array. That way the next iteration can skip this\n\t\t// element.\n\t\tif (index!=null) {\n\t\t\toldVNode = oldChildren[index];\n\t\t\toldChildren[index] = null;\n\t\t}\n\n\t\tnextDom = childDom!=null && childDom.nextSibling;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(oldVNode==null ? null : oldVNode._dom, parentDom, childVNode, oldVNode, isSvg, excessDomChildren, null);\n\n\t\t// Only proceed if the vnode has not been unmounted by `diff()` above.\n\t\tif (childVNode!=null && newDom !=null) {\n\t\t\t// Store focus in case moving children around changes it. Note that we\n\t\t\t// can't just check once for every tree, because we have no way to\n\t\t\t// differentiate wether the focus was reset by the user in a lifecycle\n\t\t\t// hook or by reordering dom nodes.\n\t\t\tfocus = document.activeElement;\n\n\t\t\tif (childVNode._lastDomChild != null) {\n\t\t\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t\t\t// have a non-null _lastDomChild. Continue the diff from the end of\n\t\t\t\t// this Fragment's DOM tree.\n\t\t\t\tnewDom = childVNode._lastDomChild;\n\t\t\t}\n\t\t\telse if (excessDomChildren==oldVNode || newDom!=childDom || newDom.parentNode==null) {\n\t\t\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t\t\t// The values only have the same type when `null`.\n\n\t\t\t\touter: if (childDom==null || childDom.parentNode!==parentDom) {\n\t\t\t\t\tparentDom.appendChild(newDom);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsibDom = childDom;\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ((sibDom=sibDom.nextSibling) && j++<oldChildrenLength/2) {\n\t\t\t\t\t\tif (sibDom===newDom) {\n\t\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparentDom.insertBefore(newDom, childDom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Restore focus if it was changed\n\t\t\tif (focus!==document.activeElement) {\n\t\t\t\tfocus.focus();\n\t\t\t}\n\n\t\t\tchildDom = newDom!=null ? newDom.nextSibling : nextDom;\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode. Only used by `hydrate`\n\tif (excessDomChildren!=null && newParentVNode.type!==Fragment) for (i=excessDomChildren.length; i--; ) if (excessDomChildren[i]!=null) removeNode(excessDomChildren[i]);\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i=oldChildrenLength; i--; ) if (oldChildren[i]!=null) unmount(oldChildren[i]);\n}\n\n/**\n * Flatten a virtual nodes children to a single dimensional array\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @param {Array<import('../internal').VNode | null>} [flattened] An flat array of children to modify\n */\nexport function toChildArray(children, flattened, map) {\n\tif (flattened == null) flattened = [];\n\tif (children==null || typeof children === 'boolean') {}\n\telse if (Array.isArray(children)) {\n\t\tfor (let i=0; i < children.length; i++) {\n\t\t\ttoChildArray(children[i], flattened);\n\t\t}\n\t}\n\telse {\n\t\tflattened.push(map ? map(children) : children);\n\t}\n\n\treturn flattened;\n}\n","import { EMPTY_ARR } from './constants';\nimport { diffChildren } from './diff/children';\nimport { createElement, Fragment } from './create-element';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tlet oldVNode = parentDom._prevVNode;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\tdiffChildren(parentDom, parentDom._prevVNode = vnode, oldVNode, parentDom.ownerSVGElement!==undefined, oldVNode ? null : EMPTY_ARR.slice.call(parentDom.childNodes), vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tparentDom._prevVNode = null;\n\trender(vnode, parentDom);\n}\n","import { assign } from './util';\nimport { EMPTY_ARR } from './constants';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n */\nexport function cloneElement(vnode, props) {\n\tprops = assign(assign({}, vnode.props), props);\n\tif (arguments.length>2) props.children = EMPTY_ARR.slice.call(arguments, 2);\n\treturn createVNode(vnode.type, props, null, props.key || vnode.key, props.ref || vnode.ref);\n}\n"],"names":["const","CAMEL_REG","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","options","createElement","type","props","children","i","ref","key","arguments","length","push","defaultProps","undefined","createVNode","text","vnode","_children","_dom","_lastDomChild","createRef","Fragment","coerceToVNode","possibleVNode","Array","isArray","diffProps","dom","newProps","oldProps","isSvg","setProperty","name","value","oldValue","v","s","useCapture","nameLower","style","cssText","replace","test","toLowerCase","substring","addEventListener","eventProxy","removeEventListener","_listeners","removeAttribute","setAttribute","e","this","event","assign","obj","let","removeNode","node","parentNode","removeChild","diff","parentDom","newVNode","oldVNode","excessDomChildren","force","unmount","newType","diffChildren","diffElementNodes","applyRef","diffed","child","oldHtml","newHtml","d","nodeType","localName","document","createTextNode","createElementNS","data","childNodes","slice","call","attributes","className","dangerouslySetInnerHTML","__html","innerHTML","multiple","current","skipRemove","r","newParentVNode","oldParentVNode","childVNode","j","p","index","newDom","nextDom","sibDom","focus","newChildren","toChildArray","oldChildren","oldChildrenLength","childDom","nextSibling","activeElement","outer","appendChild","insertBefore","flattened","map","render","_prevVNode","ownerSVGElement","hydrate","cloneElement"],"mappings":"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"}